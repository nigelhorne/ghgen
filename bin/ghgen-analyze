#!/usr/bin/env perl
use v5.36;
use warnings;
use YAML::XS qw(LoadFile);
use Path::Tiny;
use Term::ANSIColor qw(colored);

# Check if we're in a git repo with workflows
my $workflows_dir = path('.github/workflows');
unless ($workflows_dir->exists && $workflows_dir->is_dir) {
    die colored(['red'], "Error: ") . "No .github/workflows directory found\n" .
        "Run this from the root of a repository with GitHub Actions.\n";
}

say colored(['bold cyan'], "GitHub Actions Workflow Analyzer");
say colored(['cyan'], "=" x 50);
say "";

my @all_issues;
my $total_workflows = 0;

# Analyze each workflow file
for my $file (sort $workflows_dir->children(qr/\.ya?ml$/i)) {
    $total_workflows++;
    say colored(['bold'], "ðŸ“„ Analyzing: ") . $file->basename;

    my $workflow;
    eval { $workflow = LoadFile($file) };
    if ($@) {
        say colored(['red'], "  âœ— Failed to parse YAML: $@");
        next;
    }
    
    my @issues = analyze_workflow($workflow, $file->basename);
    
    if (@issues) {
        for my $issue (@issues) {
            say "  " . colored(['yellow'], "âš  ") . $issue->{message};
            if ($issue->{fix}) {
                say colored(['cyan'], "     ðŸ’¡ Fix:");
                for my $line (split /\n/, $issue->{fix}) {
                    say "     " . $line;
                }
            }
            push @all_issues, { file => $file->basename, %$issue };
        }
    } else {
        say "  " . colored(['green'], "âœ“ No issues found");
    }
    say "";
}

# Summary
say colored(['bold cyan'], "=" x 50);
say colored(['bold'], "Summary:");
say "  Workflows analyzed: $total_workflows";
say "  Total issues found: " . scalar(@all_issues);

if (@all_issues) {
    say "";
    say colored(['bold yellow'], "Recommendations:");
    my %by_type;
    push @{$by_type{$_->{type}}}, $_ for @all_issues;
    
    for my $type (sort keys %by_type) {
        my $count = scalar @{$by_type{$type}};
        say "  â€¢ " . colored(['yellow'], "$type") . ": $count workflow(s) affected";
    }
}

exit(@all_issues ? 1 : 0);

# ============================================================================
# Analysis Functions
# ============================================================================

sub analyze_workflow($workflow, $filename) {
    my @issues;
    
    # Check 1: Missing dependency caching
    unless (has_caching($workflow)) {
        my $cache_suggestion = get_cache_suggestion($workflow);
        push @issues, {
            type => 'performance',
            severity => 'medium',
            message => 'No dependency caching found - this increases build times and costs',
            fix => $cache_suggestion
        };
    }
    
    # Check 2: Using unpinned action versions
    my @unpinned = find_unpinned_actions($workflow);
    if (@unpinned) {
        push @issues, {
            type => 'security',
            severity => 'high',
            message => "Found " . scalar(@unpinned) . " action(s) using \@master or \@main instead of pinned versions",
            fix => "Replace \@master/\@main with specific version tags:\n" .
                   join("\n", map { "       $_" } map { s/\@(master|main)$/\@v4/r } @unpinned[0..min(2, $#unpinned)])
        };
    }
    
    # Check 3: Overly broad triggers
    if (has_broad_triggers($workflow)) {
        push @issues, {
            type => 'cost',
            severity => 'medium',
            message => 'Workflow triggers on all pushes - consider using path filters or specific branches',
            fix => "Add trigger filters to reduce unnecessary runs:\n" .
                   "     on:\n" .
                   "       push:\n" .
                   "         branches: [main, develop]\n" .
                   "         paths:\n" .
                   "           - 'src/**'\n" .
                   "           - 'package.json'"
        };
    }
    
    # Check 4: Missing concurrency controls
    unless ($workflow->{concurrency}) {
        push @issues, {
            type => 'cost',
            severity => 'low',
            message => 'No concurrency group defined - old runs will continue even when superseded',
            fix => "Add concurrency control to cancel outdated runs:\n" .
                   "     concurrency:\n" .
                   "       group: \${{ github.workflow }}-\${{ github.ref }}\n" .
                   "       cancel-in-progress: true"
        };
    }
    
    # Check 5: Jobs that could be parallelized
    my @sequential = find_sequential_jobs($workflow);
    if (@sequential) {
        push @issues, {
            type => 'performance',
            severity => 'low',
            message => "Found " . scalar(@sequential) . " job(s) that could potentially run in parallel"
        };
    }
    
    # Check 6: Outdated runner versions
    if (has_outdated_runners($workflow)) {
        push @issues, {
            type => 'maintenance',
            severity => 'low',
            message => 'Using older runner versions (ubuntu-18.04, etc.) - consider updating'
        };
    }
    
    return @issues;
}

sub has_caching($workflow) {
    my $jobs = $workflow->{jobs} or return 0;
    
    for my $job (values %$jobs) {
        my $steps = $job->{steps} or next;
        for my $step (@$steps) {
            return 1 if $step->{uses} && $step->{uses} =~ /actions\/cache/;
        }
    }
    return 0;
}

sub find_unpinned_actions($workflow) {
    my @unpinned;
    my $jobs = $workflow->{jobs} or return @unpinned;
    
    for my $job (values %$jobs) {
        my $steps = $job->{steps} or next;
        for my $step (@$steps) {
            next unless $step->{uses};
            if ($step->{uses} =~ /\@(master|main)$/) {
                push @unpinned, $step->{uses};
            }
        }
    }
    return @unpinned;
}

sub has_broad_triggers($workflow) {
    my $on = $workflow->{on};
    return 0 unless $on;
    
    # Check if push trigger has no path or branch filters
    if (ref $on eq 'HASH' && $on->{push}) {
        my $push = $on->{push};
        return 1 if ref $push eq '' || (!$push->{paths} && !$push->{branches});
    }
    
    # Simple array of triggers including 'push'
    if (ref $on eq 'ARRAY' && grep { $_ eq 'push' } @$on) {
        return 1;
    }
    
    return 0;
}

sub find_sequential_jobs($workflow) {
    my @sequential;
    my $jobs = $workflow->{jobs} or return @sequential;
    
    # Find jobs without 'needs' that could potentially be parallel
    my @job_names = keys %$jobs;
    return @sequential if @job_names <= 1;  # Only one job
    
    my $has_dependencies = 0;
    for my $job (values %$jobs) {
        $has_dependencies = 1 if $job->{needs};
    }
    
    # If there are multiple jobs but none specify dependencies,
    # they're already parallel (false positive)
    return @sequential if !$has_dependencies;
    
    # Jobs with needs that point to other jobs with needs
    # could potentially be optimized
    for my $name (@job_names) {
        my $job = $jobs->{$name};
        if ($job->{needs}) {
            push @sequential, $name;
        }
    }
    
    return @sequential;
}

sub has_outdated_runners($workflow) {
    my $jobs = $workflow->{jobs} or return 0;
    
    for my $job (values %$jobs) {
        my $runs_on = $job->{'runs-on'} or next;
        return 1 if $runs_on =~ /ubuntu-18\.04|ubuntu-16\.04|macos-10\.15/;
    }
    return 0;
}

sub min($a, $b) {
    return $a < $b ? $a : $b;
}

sub get_cache_suggestion($workflow) {
    my $jobs = $workflow->{jobs} or return "Add caching step";
    
    # Try to detect project type from steps
    my $detected_type = detect_project_type($workflow);
    
    my %cache_configs = (
        npm => "- uses: actions/cache\@v4\n" .
               "       with:\n" .
               "         path: ~/.npm\n" .
               "         key: \${{ runner.os }}-node-\${{ hashFiles('**/package-lock.json') }}\n" .
               "         restore-keys: |\n" .
               "           \${{ runner.os }}-node-",
        
        pip => "- uses: actions/cache\@v4\n" .
               "       with:\n" .
               "         path: ~/.cache/pip\n" .
               "         key: \${{ runner.os }}-pip-\${{ hashFiles('**/requirements.txt') }}\n" .
               "         restore-keys: |\n" .
               "           \${{ runner.os }}-pip-",
        
        cargo => "- uses: actions/cache\@v4\n" .
                 "       with:\n" .
                 "         path: |\n" .
                 "           ~/.cargo/bin/\n" .
                 "           ~/.cargo/registry/index/\n" .
                 "           ~/.cargo/registry/cache/\n" .
                 "           target/\n" .
                 "         key: \${{ runner.os }}-cargo-\${{ hashFiles('**/Cargo.lock') }}",
        
        bundler => "- uses: actions/cache\@v4\n" .
                   "       with:\n" .
                   "         path: vendor/bundle\n" .
                   "         key: \${{ runner.os }}-gems-\${{ hashFiles('**/Gemfile.lock') }}\n" .
                   "         restore-keys: |\n" .
                   "           \${{ runner.os }}-gems-",
    );
    
    return $cache_configs{$detected_type} // 
           "Add a caching step based on your dependency manager:\n" .
           "       See: https://docs.github.com/en/actions/using-workflows/caching-dependencies";
}

sub detect_project_type($workflow) {
    my $jobs = $workflow->{jobs} or return 'unknown';
    
    for my $job (values %$jobs) {
        my $steps = $job->{steps} or next;
        for my $step (@$steps) {
            my $run = $step->{run} // '';
            return 'npm' if $run =~ /npm (install|ci)/;
            return 'pip' if $run =~ /pip install/;
            return 'cargo' if $run =~ /cargo (build|test)/;
            return 'bundler' if $run =~ /bundle install/;
        }
    }
    return 'unknown';
}
